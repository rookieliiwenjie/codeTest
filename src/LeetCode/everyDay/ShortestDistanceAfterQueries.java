package LeetCode.everyDay;

import java.util.*;

public class ShortestDistanceAfterQueries {
    /**
     * 给你一个整数 n 和一个二维整数数组 queries。
     * <p>
     * 有 n 个城市，编号从 0 到 n - 1。初始时，每个城市 i 都有一条单向道路通往城市 i + 1（ 0 <= i < n - 1）。
     * <p>
     * queries[i] = [ui, vi] 表示新建一条从城市 ui 到城市 vi 的单向道路。每次查询后，
     * 你需要找到从城市 0 到城市 n - 1 的最短路径的长度。
     * <p>
     * 返回一个数组 answer，对于范围 [0, queries.length - 1] 中的每个 i，
     * answer[i] 是处理完前 i + 1 个查询后，从城市 0 到城市 n - 1 的最短路径的长度。
     * <p>
     * <p>
     * 示例 1：
     * <p>
     * 输入： n = 5, queries = [[2, 4], [0, 2], [0, 4]]
     * <p>
     * 输出： [3, 2, 1]
     *
     * @param n
     * @param queries
     * @return
     */
    public static void main(String[] args) {
        ShortestDistanceAfterQueries shortestDistanceAfterQueries = new ShortestDistanceAfterQueries();
        int n = 49;
        int[][] arr = {{1, 21}, {25, 36}, {19, 28}, {3, 35}, {32, 41}, {6, 36}, {35, 47}, {10, 38}, {24, 45}, {1, 16}, {5, 12}, {35, 44}, {4, 41}, {35, 48}, {1, 37}, {36, 39}, {15, 44}, {2, 44}, {7, 44}, {6, 17}, {12, 20}, {1, 33}, {9, 35}, {6, 28}, {15, 42}, {10, 43}, {7, 22}, {23, 38}, {9, 40}, {37, 42}, {16, 29}, {21, 30}, {7, 31}, {17, 19}, {8, 20}, {7, 16}, {8, 43}, {14, 40}, {35, 41}, {6, 21}, {12, 18}, {14, 21}, {18, 47}, {0, 20}, {34, 38}, {2, 34}, {11, 42}, {7, 36}, {25, 35}, {10, 47}, {0, 9}, {28, 44}, {29, 34}, {4, 20}, {22, 32}, {29, 40}, {4, 34}, {12, 46}, {32, 43}, {26, 41}, {29, 37}, {0, 44}, {14, 24}, {22, 46}, {39, 41}, {21, 33}, {13, 48}, {15, 39}, {8, 35}, {38, 43}, {0, 16}, {4, 25}, {18, 42}, {38, 42}, {29, 43}, {35, 46}, {25, 27}, {11, 28}, {1, 43}, {7, 17}, {13, 45}, {21, 44}, {4, 6}, {12, 19}, {19, 42}, {14, 22}, {23, 34}, {26, 40}, {24, 35}, {29, 35}, {24, 30}, {21, 31}, {24, 33}, {9, 41}, {7, 33}, {1, 39}, {10, 40}, {4, 48}, {0, 13}, {14, 46}, {43, 45}, {3, 39}, {4, 23}, {12, 17}, {15, 18}, {16, 23}, {10, 42}, {0, 17}, {39, 43}, {13, 29}, {8, 29}, {42, 46}, {29, 31}, {7, 45}, {4, 22}, {30, 41}, {9, 42}, {1, 28}, {3, 24}, {4, 18}, {1, 17}, {11, 23}, {22, 30}, {16, 18}, {29, 32}, {39, 45}, {5, 38}, {17, 46}, {3, 20}, {14, 31}, {12, 29}, {24, 34}, {13, 15}, {33, 39}, {2, 9}, {18, 41}, {20, 45}, {30, 35}, {13, 16}, {11, 41}, {0, 2}, {19, 45}, {5, 16}, {35, 43}, {8, 32}, {19, 38}, {18, 35}, {38, 46}, {6, 45}, {15, 36}, {21, 43}, {20, 33}, {32, 34}, {12, 27}, {17, 38}, {4, 19}, {27, 40}, {8, 34}, {1, 8}, {1, 34}, {2, 16}, {3, 14}, {11, 14}, {3, 6}, {17, 47}, {21, 26}, {12, 35}, {23, 43}, {12, 41}, {8, 30}, {24, 48}, {2, 42}, {30, 47}, {20, 32}, {14, 37}, {18, 37}, {10, 48}, {9, 14}, {13, 21}, {26, 43}, {7, 9}, {9, 13}, {24, 26}, {24, 43}, {3, 27}, {1, 14}, {14, 42}, {5, 10}, {17, 33}, {13, 28}, {4, 11}, {25, 30}, {21, 39}, {16, 27}, {2, 7}, {7, 24}, {2, 35}, {11, 29}, {3, 45}, {3, 40}, {31, 38}, {32, 36}, {14, 25}, {11, 37}, {1, 32}, {32, 47}, {26, 38}, {17, 20}, {24, 28}, {40, 46}, {23, 26}, {4, 15}, {4, 31}, {31, 41}, {13, 19}, {13, 30}, {27, 44}, {35, 42}, {35, 40}, {14, 44}, {2, 14}, {25, 44}, {6, 48}, {19, 35}, {37, 47}, {5, 43}, {0, 8}, {13, 17}, {7, 29}, {12, 32}, {19, 46}, {23, 29}, {26, 29}, {13, 24}, {22, 24}, {0, 27}, {0, 3}, {27, 34}, {14, 16}, {6, 47}, {22, 44}, {15, 48}, {19, 24}, {11, 35}, {13, 20}, {15, 37}, {8, 45}, {33, 38}, {23, 40}, {16, 43}, {15, 21}, {9, 15}, {31, 34}, {32, 44}, {17, 28}, {1, 41}, {3, 46}, {16, 30}, {30, 43}, {17, 44}, {8, 36}, {32, 37}, {28, 43}, {9, 27}, {22, 38}, {28, 38}, {8, 33}, {2, 24}, {6, 11}, {21, 28}, {18, 30}, {2, 43}, {26, 36}, {23, 25}, {4, 8}, {21, 47}, {0, 38}, {30, 40}, {12, 42}, {30, 34}, {1, 47}, {14, 19}, {5, 15}, {23, 45}, {41, 46}, {9, 39}, {18, 28}, {7, 18}, {16, 28}, {30, 46}, {5, 41}, {2, 18}, {14, 26}, {24, 39}, {4, 46}, {4, 26}, {3, 38}, {18, 38}, {8, 15}, {9, 16}, {38, 48}, {19, 34}, {37, 48}, {32, 38}, {16, 41}, {18, 43}, {44, 47}, {7, 42}, {15, 24}, {2, 25}, {25, 47}, {16, 47}, {43, 48}, {31, 37}, {5, 45}, {16, 22}, {11, 44}, {10, 24}, {5, 20}, {3, 16}, {19, 30}, {8, 37}, {29, 41}, {10, 12}, {3, 23}, {9, 46}, {31, 44}, {19, 25}, {20, 46}, {13, 35}, {9, 18}, {5, 25}, {18, 40}, {33, 46}, {20, 48}, {18, 27}, {3, 7}, {35, 37}, {33, 41}, {11, 33}, {0, 6}, {18, 26}, {0, 32}, {24, 47}, {9, 12}, {44, 46}, {25, 40}, {7, 10}, {12, 30}, {22, 43}, {20, 23}, {5, 7}, {27, 39}, {0, 26}, {5, 32}, {10, 34}, {10, 23}, {13, 34}, {10, 36}, {0, 4}, {5, 14}, {13, 40}, {29, 48}, {26, 28}, {6, 14}, {18, 44}, {38, 47}, {2, 12}, {12, 15}, {6, 8}, {2, 48}, {7, 34}, {11, 18}, {1, 22}, {30, 32}, {9, 47}, {10, 35}, {20, 41}, {15, 33}, {34, 44}, {22, 29}, {13, 37}, {10, 29}, {33, 44}, {1, 35}, {28, 40}, {22, 34}, {11, 45}, {9, 38}, {31, 42}, {9, 26}, {6, 40}, {14, 36}, {17, 36}, {18, 24}, {26, 48}, {12, 39}, {28, 41}, {0, 31}, {13, 36}, {17, 41}, {26, 39}, {32, 42}, {29, 33}, {8, 22}, {7, 13}, {4, 13}, {5, 48}, {41, 43}, {5, 37}, {8, 28}, {15, 19}, {4, 9}, {14, 43}, {4, 40}, {8, 23}, {25, 32}, {8, 19}, {6, 20}, {0, 39}, {3, 10}, {22, 48}, {8, 48}, {28, 48}, {37, 43}, {21, 29}, {4, 12}, {1, 24}, {19, 33}, {6, 32}, {20, 29}, {6, 19}, {2, 8}, {34, 42}, {14, 18}, {9, 48}, {1, 46}, {3, 47}, {0, 7}, {16, 36}};
        int[] ints = shortestDistanceAfterQueries.shortestDistanceAfterQueries(n, arr);
        for (int i = 0; i < ints.length; i++) {
            System.out.println(ints[i]);
        }
    }

    HashMap<Integer, List<Integer>> hashMap = new HashMap();
    int cityNum = 0;
    int minSUm = Integer.MAX_VALUE;

    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {
        int[] result = new int[queries.length];
        cityNum = n - 1;
        for (int i = 0; i < n - 1; i++) {
            List<Integer> list = new ArrayList<>();
            list.add(i + 1);
            hashMap.put(i, list);
        }
        for (int querie = 0; querie < queries.length; querie++) {
            List<Integer> list = hashMap.get(queries[querie][0]);
            list.add(queries[querie][1]);
            hashMap.put(queries[querie][0], list);
            List<Integer> list1 = hashMap.get(0);
            if (list1.contains(cityNum)) {
                result[querie] = 1;
            } else {
                minNum(hashMap.get(0), 1);
                result[querie] = minSUm;
            }
            minSUm = Integer.MAX_VALUE;
        }
        return result;
    }

    public void minNum(List<Integer> nowDistance, int sum) {
        if (nowDistance == null) {
            return;
        }
        for (Integer now : nowDistance) {
            List<Integer> list = hashMap.get(now);
            if (list.contains(cityNum)) {
                sum++;
                minSUm = Math.min(minSUm, sum);
                return;
            }
            minNum(hashMap.get(now), sum + 1);
        }
    }


    public int[] shortestDistanceAfterQueries2(int n, int[][] queries) {
        List<List<Integer>> neighbors = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            neighbors.add(new ArrayList<>());
        }
        for (int i = 0; i < n - 1; i++) {
            neighbors.get(i).add(i + 1);
        }
        int[] res = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            neighbors.get(queries[i][0]).add(queries[i][1]);
            res[i] = bfs(n, neighbors);
        }
        return res;
    }

    private int bfs(int n, List<List<Integer>> neighbors) {
        int[] dist = new int[n];
        for (int i = 1; i < n; i++) {
            dist[i] = -1;
        }
        Queue<Integer> q = new LinkedList<>();
        q.add(0);
        while (!q.isEmpty()) {
            int x = q.poll();
            for (int y : neighbors.get(x)) {
                if (dist[y] >= 0) {
                    continue;
                }
                q.add(y);
                dist[y] = dist[x] + 1;
            }
        }
        return dist[n - 1];
    }

    /**
     * 根据题意，对于任一单向道路的起始点 u，终止点 v，都有 u<v，那么从城市 0 到任一城市的路径上，所经过的城市编号是单调递增的。
     * 令 dp[i] 表示城市 0 到城市 i 的最短路径，同时使用 prev[i] 记录通往城市 i 的所有单向道路的起始城市集合，
     * 那么对于 i>0，有 dp[i]=min
     * j∈prev[i]
     * ​
     *  dp[j]+1。
     * 根据以上推论，我们可以遍历 queries，在每次查询时，更新 prev 数组，
     * 然后更新 dp 数组。注意到，每次新建一条从城市 u 到城市 v 的单向道路时，
     * 只有 i≥v 的 dp[i] 会发生变化，因此更新 dp 可以从 v 开始更新。
     *
     */

    public int[] shortestDistanceAfterQueries3(int n, int[][] queries) {
        List<List<Integer>> prev = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            prev.add(new ArrayList<>());
        }
        int[] dp = new int[n];
        for (int i = 1; i < n; i++) {
            prev.get(i).add(i - 1);
            dp[i] = i;
        }
        int [] res = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            prev.get(queries[i][1]).add(queries[i][0]);
            for (int v = queries[i][1]; v < n; v++) {
                for (int u : prev.get(v)) {
                    dp[v] = Math.min(dp[v], dp[u] + 1);
                }
            }
            res[i] = dp[n - 1];
        }
        return res;
    }

}
