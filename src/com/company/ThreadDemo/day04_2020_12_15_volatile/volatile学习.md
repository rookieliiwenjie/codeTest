# **_volatile_**
一、定义特性:

1.volatile是轻量级的synchronized

2.可见性:kejianxin

3.不可重排

二、原理

当加上volatile关键字的时候，我们通过查看汇编代码可以IA-32架构软件得知加上了前缀lock 0x000000010bfba5f5: lock addl $0x0,(%rsp) 
当加上lock会为我们干啥呢。

1、将当前处理器的值写会到系统内存中

2、这个写回内存的操作 会使其他的cup里catch该内存的数据失效。


小记：为了提高处理速度，处理器cpu和接不直接和内存进行通信，而是先将系统内存中的数据读到L1L2缓冲上后再进行操作，但是啥时候将值刷新到内存中就不知道，
但是当我们加上volatile是也就是加上lock时，在我们进行修改以后，就会将修改后的数据写回到系统内存中，但是这样就引出了一个新的问题，其他处理器上的
缓冲是不知道数据已经修改了，所以在多处理器中有了缓冲一致性。

**缓冲一致性：** 
在多处理器的情况下，要实现缓冲一致性，每个处理器通过嗅探在总线上的传播过来的数据进行判断是否已经
过期，如果已经过期则在当前处理器修改的时候发现数据内存中的值是否过期了，当发现自己catch line
数据已经过期则将自己catch line中的数据设置为无效，然后当要对该数据进行操作时，则从系统内存中获取
最新的值。

1.Lock前缀会导致处理器缓存写回到系统内存中：
Lock前缀在执行时相当于将系统声言lock信号，在多处理器下，Lock为了保证在该声言期间独占系统内存，
所以会锁住总线（也就是其他处理器无法访问和更新因为它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存。）
但是现在的处理器是不锁总线的，而是通过锁缓冲，也就是如果数据已经在缓冲中
则不会在总线上声言lock，相反他会锁住这块内存区域的缓冲些回到内存中，并通过缓冲一致性保证修改的原子性，这个操作叫做缓冲锁定，
_`缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据`_。

2、一个处理器的数据写回到处理器以后，会导致其他处理器的数据失效。
目前inter64处理器和IA-32处理器都是使用MESI（修改（modify），独享（Exclusive），共享shared、无效（invalid））
控制协议去维护内部缓冲和其他处理器缓冲的一致性。在多处理器下，目前的处理器都能嗅探访问系统内存
和他们内部缓冲，处理器使用嗅探技术来保证它自己内部缓冲、系统内存和其他各处理器内部缓冲的数据在总线上的一致性
通过嗅探发现一个处理器企图修改数据，同时这个数据是系统内存的共享区，那么嗅探的处理器
就会是自己的 缓冲行失效，强制拉去内存中的数据；


 二、优化
 
1、著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类Linked- TransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性 能。LinkedTransferQueue的代码如下。
  /** 队列中的头部节点 */
  private transient f?inal PaddedAtomicReference<QNode> head;
  /** 队列中的尾部节点 */
  private transient f?inal PaddedAtomicReference<QNode> tail;
  static f?inal class PaddedAtomicReference <T> extends AtomicReference T> {
  // 使用很多4个字节的引用追加到64个字节
  Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe; PaddedAtomicReference(T r) {
  super(r); }
  }
  public class AtomicReference <V> implements java.io.Serializable {
          private volatile V value;
  // 省略其他代码 }
  主要的原因就是，如果我们将一个队列的heat和tail都不足64那么我们就会将他们都放到一个高速缓冲行那么对于共享变量，当我们进行数据修改时，会锁住
  自己的缓存行和对应的内存，在多处理器下根据缓冲一致性，那么就会导致一些处理器拿不到自己的tail，而出队和入队有需要大量的修改head和tail
  但是这样可能就会出现一个问题那就是我如果更新head而想去那tail的时候，那么我锁住的就是所有这样影响我们
  拿tail，为啥是64呢，因为大多数的处理器L1L2L3缓冲行都是64个字节，
 
 
 啥情况不使用追加字节，
 1。当cpu处理器不是64位占一个的高速缓冲行时
 2、不是特别频繁的进行修改的时候没有必要。因为使用追加字节的方式需要处理器读取更多的字节到高速 缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常 小，就没必要通过追加字节的方式来避免相互锁定











```

save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```